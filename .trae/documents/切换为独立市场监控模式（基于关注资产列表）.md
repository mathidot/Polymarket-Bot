## 目标

* 将行情采集改为“基于 slug 的关注列表”，按 slug → marketId → tokenId 的链路解析要监控的资产，并建立 Yes/No 配对。

* 完全脱离钱包持仓数据进行行情采集与配对，仍保留现有尖刺检测与交易、退出逻辑。

## 配置与输入

* `.env` 新增：

  * `WATCHLIST_SLUGS_JSON=./watchlist_slugs.json`（文件内容形如 `{ "slugs": ["lol-t1-kt-2025-11-09", "csgo-..." ] }`）

  * 可选：`FETCH_INTERVAL_MS=1000`、`PRICE_SOURCE=mid`（mid/ask/bid）

* 也支持直接用 `.env` 提供：`WATCHLIST_SLUGS=lol-t1-kt-2025-11-09,csgo-...`（两种方式择一）

## 新增模块与函数

* 新增 `polymarket_bot/slug_source.py`：负责从 slug 解析到 tokenId 列表与配对

  * 常量：`EVENTS_URL`、`SLUG_URL`、`MARKET_URL`

  * HTTP 帮助：`_fetch_json(url, params=None, headers=...)`（加入 UA、重试与指数退避）

  * `get_all_slug_events()`：分页拉取未关闭市场的全部 slug（保留你提供的分页与 `next_cursor` 逻辑）

  * `get_market_from_slug(eventslug: str) -> list[str]`：按 slug 获取 marketId 列表（保留校验与异常处理）

  * `get_token_from_market(market_id: str) -> list[str]`：按 marketId 获取 clobTokenIds（JSON 字符串），返回 `[yes_token, no_token]`

  * `resolve_tokens_from_watchlist(slugs: list[str]) -> dict`：综合以上函数，将所有 slug 解析为 `{ token_id: {pair: other_token, eventslug: slug, outcome: "YES/NO"} }`

## 行情采集改造

* 改写 `update_price_history`：

  * 启动时从 `WATCHLIST_SLUGS` 或 JSON 文件加载 slugs，调用 `resolve_tokens_from_watchlist` 获得监控 token 列表与配对映射。

  * 每轮遍历 token 列表：

    * 调用 `client.get_order_book(token)` 与/或 `client.get_price(token, side)`，按 `PRICE_SOURCE` 计算 `price`（mid/ask/bid）。

    * 写入 `state.add_pr``ice(token, now, price, ev``entslug=slug, outcome="YES/NO")`

  * 首次数据就绪事件的判断改为：watchlist 中任一 token 出现价格历史样本。

  * 不再调用 `fetch_positions_with_retry` 与 `state.update_positions`。

## 配对与状态

* 在解析 tokens 时，立即 `state.add_asset_pair(yes_token, no_token)`；后续检测逻辑使用该映射。

* 若某个市场不是二元（没有两个 token），直接跳过，并记录告警。

## 交易与退出适配（保持无持仓监控）

* 买入成功后从响应读取 `filledAmount`，新增 `TradeInfo.shares` 并保存。

* 卖出与退出使用 `active_trades` 中的 `entry_price` 与 `shares` 计算 PnL（替换原先从 `positions` 读取 `avg_price/shares` 的路径）。

* 若未来需要合并加仓：提供加权合并方法更新 `entry_price` 与 `shares`。

## 限流与稳健性

* `_fetch_json` 加 UA/Accept/超时与指数退避，尊重 `Retry-After`。

* 采集线程引入 `FETCH_INTERVAL_MS` 与全局 QPS 限制，避免 Cloudflare 1015。

* 对零价与异常值在写入前过滤，防止污染历史。

## 日志与可观测性

* 启动打印所加载的 slug 数、解析出的 marketId 与 tokenId 数量（含跳过原因）。

* 每轮采集输出采集源（mid/ask/bid）、资产数与失败列表。

## 测试计划

* 单元测试：

  * 为 `slug_source` 提供伪造 JSON 响应，验证 `slug → market → token` 解析链路、异常与跳过逻辑。

  * 验证 `update_price_history` 在无 positions 下能按 watchlist 写入价格历史并触发事件。

* 集成测试：

  * 对一个已知 slug（你的示例）跑通解析与尖刺检测至下单闭环（可用模拟/最小真实市场）。

## 迁移步骤

* 在 `.env` 增加：`WATCHLIST_SLUGS_JSON=./watchlist_slugs.json` 或 `WATCHLIST_SLUGS=...`

* 创建 `watchlist_slugs.json`：

  ```json
  { "slugs": [ "lol-t1-kt-2025-11-09" ] }
  ```

* 配置 `FETCH_INTERVAL_MS=1000`、`PRICE_SOURCE=mid`（按需调整）。

* 启动 `python app.py`，观察日志中“基于 slug 的采集”与“解析到的 tokenId”。

## 风险与回退

* 若 API 变更导致 `next_cursor` 字段失效，回退为按时间范围分段拉取或直接用固定 watchlist。

* 若单市场不成对（无二元），仅以单腿模式运行或跳过该 slug。

